// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ComputeFluxDensityOfFerromagnetic
#pragma kernel ComputeAddedFerromagnetic
#pragma kernel ComputeFerromagnetic

RWStructuredBuffer<float> ferroMatrixTop;		// number of coil * number of point * 4byte
RWStructuredBuffer<float> ferroMatrixBottom;	// number of coil * number of point * 4byte
RWStructuredBuffer<float> ferroMatrixAdded;		// number of coil * number of point * 4byte
RWStructuredBuffer<float> ferroMagnetics;		// number of point * 4byte

StructuredBuffer<float3> pointPosition;	// number of point * 12byte

StructuredBuffer<float3> coilPosition;	// number of coil * 12byte
StructuredBuffer<float3> coilFront;		// number of coil * 12byte
StructuredBuffer<float3> coilRight;		// number of coil * 12byte
StructuredBuffer<float> coilHalfHeight;	// number of coil * 4byte

float sigma;

float divTheta;
float divRadius;
int countTheta;
int countRadius;

int coilCount;
int pointCount;

// クォータニオンの回転を実行する
inline float4 rotation(float4 l, float4 r)
{
	return float4(
		l.w * r.x + l.x * r.w + l.y * r.z - l.z * r.y,
		l.w * r.y - l.x * r.z + l.y * r.w + l.z * r.x,
		l.w * r.z + l.x * r.y + l.y * r.x + l.z * r.w,
		l.w * r.w - l.x * r.x - l.y * r.y - l.z * r.z
		);
}

// 強磁性体の磁束密度を求める
// id.x: coilCount
// id.y: pointCount
// id.z: top or bottom
[numthreads(4,128,2)]
void ComputeFluxDensityOfFerromagnetic (uint3 id : SV_DispatchThreadID)
{
	// TODO: insert actual code here!
	for (int ti = 0; ti < countTheta; ++ti)
	{
		for (int ri = 0; ri < countRadius; ++ri)
		{
			float3 front = coilFront[id.x];
			float3 pointPos = pointPosition[id.y];
			float3 coilPos = coilPosition[id.x];

			float dr = ri * divRadius;
			float dt = ti * divTheta;

			float upper = dr * sigma;

			float4 quat = normalize(float4(front.xyz, dt));
			float4 conj = float4(-quat.xyz, quat.w);
			float4 right = float4(coilRight[id.x].xyz, 0);

			float4 result;
			result = rotation(quat, right);
			result = rotation(normalize(result), conj);

			float height = coilHalfHeight[id.x];
			float3 inner = result.xyz * dr + pointPos - coilPos;
			float div = divRadius * divTheta;
			float under;

			if (id.z == 0)
			{
				under = pow(length(inner + front * height), 3.0);
				ferroMatrixTop[coilCount * id.x + id.y] += upper / under * div;
			}
			else
			{
				under = pow(length(inner - front * height), 3.0);
				ferroMatrixBottom[coilCount * id.x + id.y] += upper / under * div;
			}
		}
	}
}

// id.x: coilCount
// id.y: pointCount
[numthreads(8, 128, 1)]
void ComputeAddedFerromagnetic (uint3 id : SV_DispatchThreadID)
{
	int i = id.x * coilCount + id.y;
	ferroMatrixAdded[i] = ferroMatrixTop[i] - ferroMatrixBottom[i];
}

// id.x: pointCount
[numthreads(512, 1, 1)]
void ComputeFerromagnetic (uint3 id : SV_DispatchThreadID)
{
	for (int i = 0; i < coilCount; ++i)
	{
		ferroMagnetics[id.x] += ferroMatrixAdded[coilCount * i + id.x];
	}
}